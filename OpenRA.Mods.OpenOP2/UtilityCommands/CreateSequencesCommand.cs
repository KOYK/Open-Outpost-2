#region Copyright & License Information
/*
 * Copyright 2007-2018 The OpenRA Developers (see AUTHORS)
 * This file is part of OpenRA, which is free software. It is made
 * available to you under the terms of the GNU General Public License
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version. For more
 * information, see COPYING.
 */
#endregion

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using OpenRA.Mods.OpenOP2.FileSystem;
using OpenRA.Mods.OpenOP2.SpriteLoaders;

namespace OpenRA.Mods.OpenOP2.UtilityCommands
{
	class CreateSequencesCommand : IUtilityCommand
	{
		private const string OutputFilename = "..\\mods\\openop2\\sequences\\sequences-generated.yaml";

		string IUtilityCommand.Name => "--create-sequences";

		private bool onlyIdleSequence = false;
		bool IUtilityCommand.ValidateArguments(string[] args) { return ValidateArguments(args); }

		[Desc("FILENAME", "Write out the sequences that our sequence loader uses.")]
		void IUtilityCommand.Run(Utility utility, string[] args) { Run(utility, args); }

		private ModData modData;
		private PrtFile prtFile;
		private List<uint[]> framePalettes;

		public bool ValidateArguments(IReadOnlyCollection<string> args)
		{
			return args.Count >= 1;
		}

		private void Run(Utility utility, string[] args)
		{
			// HACK: The engine code assumes that Game.modData is set.
			Game.ModData = modData = utility.ModData;

			var prt = Prt.Instance;
			prtFile = prt.PrtFile;
			framePalettes = prt.FramePalettes;

			WriteSequences();
			Console.WriteLine($"Wrote sequences file: {OutputFilename}");
		}

		private void WriteSequences()
		{
			// Load from yaml
			var groupsFile = new GroupsFile();
			var groupSequences = groupsFile.Groups;

			var sb = new StringBuilder();
			sb.AppendLine("## This file was generated by CreateSequencesCommand.");
			sb.AppendLine("## Don't modify it yourself unless you know what you're doing.");
			sb.AppendLine(string.Empty);

			foreach (var groupSequence in groupSequences)
			{
				sb.AppendLine($"{groupSequence.Name}:");

				var sets = groupSequence.Sets;
				if (groupSequence.WithSingleFrameIdle)
				{
					sets = GroupsFile.AddSingleFrameIdle(sets);
				}

				var literalGroupSequenceSets = new List<GroupSequenceSet>();

				foreach (var groupSequenceSet in sets)
				{
					if (!string.IsNullOrWhiteSpace(groupSequenceSet.UseFile))
					{
						literalGroupSequenceSets.Add(groupSequenceSet);
						continue;
					}

					var typeGroupedFrames = GroupsFile.GetTypedGroupFrames(prtFile, groupSequence, groupSequenceSet, out var frameCount);

					Func<SequenceSet, int, string> getSequenceName = (inGroup, ind) =>
					{
						Func<int, string> getTypeString = (inFrameType) =>
						{
							return inFrameType switch
							{
								1 => "sprite",
								4 => "shadow",
								5 => "shadow",
								_ => "unknown"
							};
						};

						//////////////////////
						var seqName = $"{groupSequenceSet.Sequence}-{getTypeString(inGroup.FrameType)}" + (ind == 0 ? string.Empty : $"-id{ind}");
						if (inGroup.FrameType == 1 && ind == 0)
						{
							seqName = groupSequenceSet.Sequence;
						}

						return seqName;
					};

					var allSequenceNames = typeGroupedFrames.Select((x, index) => getSequenceName(x, index)).ToArray();

					sb.AppendLine($"\t# All sequences: {string.Join(", ", allSequenceNames)}");
					var zIndex = 0;
					var typeIndex = 0;
					foreach (var typeGroupedFrame in typeGroupedFrames)
					{
						var sequenceName = allSequenceNames[typeIndex];
						var outputSequence = GroupsFile.GetOutputSequence(sequenceName, groupSequenceSet, typeGroupedFrame);

						if (groupSequence.WithBlankIdle && groupSequenceSet == sets.First())
						{
							sb.AppendLine("\tidle:");
							sb.AppendLine("\t\tLength: 1");
							sb.AppendLine("\t\tFacings: 1");
							sb.AppendLine("\t\tCombine:");
							sb.AppendLine("\t\t\tblank.png: idle-0");
							sb.AppendLine("\t\t\t\tFrames: 0");
							sb.AppendLine("\t\t\t\tLength: 1");
						}

						sb.AppendLine($"\t{sequenceName}:");

						if (groupSequenceSet.FacingsOverride > 0)
						{
							sb.AppendLine($"\t\tLength: 1");
							sb.AppendLine($"\t\tFacings: {groupSequenceSet.FacingsOverride}");
						}
						else
						{
							sb.AppendLine($"\t\tLength: {frameCount}");
							sb.AppendLine($"\t\tFacings: {groupSequenceSet.Length}");
						}

						sb.AppendLine($"\t\tOffset: {groupSequenceSet.OffsetX},{groupSequenceSet.OffsetY}");

						if (groupSequenceSet.OffsetZ != 0)
						{
							sb.AppendLine($"\t\tZOffset: {groupSequenceSet.OffsetZ}");
						}
						else
						{
							sb.AppendLine($"\t\tZOffset: {zIndex}");
						}

						if (groupSequenceSet.Tick.HasValue)
						{
							sb.AppendLine($"\t\tTick: {groupSequenceSet.Tick.Value}");
						}

						sb.AppendLine($"\t\tCombine:");

						foreach (var frameset in outputSequence.Framesets)
						{
							var framesString = string.Join(",", frameset.Frames);
							if (frameset.IsBlank)
							{
								sb.AppendLine($"\t\t\tblank.png: {frameset.Name}");
							}
							else
							{
								sb.AppendLine($"\t\t\top2_art.bmp: {frameset.Name}");
							}

							sb.AppendLine($"\t\t\t\tFrames: {framesString}");
							sb.AppendLine($"\t\t\t\tLength: {frameset.Frames.Count}");
							sb.AppendLine($"\t\t\t\tOffset: {frameset.OffsetX},{frameset.OffsetY}");
							sb.AppendLine($"\t\t\t\tZOffset: {zIndex}");
						}

						typeIndex++;
						zIndex -= 256;
					}

					if (onlyIdleSequence)
					{
						break;
					}
				}

				// Hack in our literal sequences
				// Used for icons only for now
				foreach (var seq in literalGroupSequenceSets)
				{
					sb.AppendLine($"\t{seq.Sequence}: {seq.UseFile}");
					sb.AppendLine($"\t\tStart: {seq.Start}");
					sb.AppendLine($"\t\tLength: {seq.Length}");
					sb.AppendLine($"\t\tOffset: {seq.OffsetX},{seq.OffsetY}");
				}

				sb.AppendLine(string.Empty);
			}

			using var sw = new StreamWriter(OutputFilename);
			sw.Write(sb.ToString());
		}
	}
}
