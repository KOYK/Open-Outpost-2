#region Copyright & License Information
/*
 * Copyright 2007-2018 The OpenRA Developers (see AUTHORS)
 * This file is part of OpenRA, which is free software. It is made
 * available to you under the terms of the GNU General Public License
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version. For more
 * information, see COPYING.
 */
#endregion

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using OpenRA.Mods.OpenOP2.FileSystem;
using OpenRA.Primitives;

namespace OpenRA.Mods.OpenOP2.UtilityCommands
{
	class CreateSequencesCommand : IUtilityCommand
	{
		class AnimationFacing
		{
			public AnimationFrame[] Frames;
		}

		class AnimationFrame
		{
			public int Frame;
			public int OffsetX;
			public int OffsetY;
		}

		private const string OutputFilename = "..\\..\\mods\\openop2\\sequences\\sequences-generated.yaml";
		private const string RulesOutputFilename = "..\\..\\mods\\openop2\\rules\\rules-generated.yaml";
		private const string RulesExampleOutputFilename = "..\\..\\mods\\openop2\\rules\\rules-example.yaml";

		string IUtilityCommand.Name => "--create-sequences";
		bool IUtilityCommand.ValidateArguments(string[] args) { return ValidateArguments(args); }

		[Desc("FILENAME", "Convert an Outpost 2 map to the OpenRA format.")]
		void IUtilityCommand.Run(Utility utility, string[] args) { Run(utility, args); }

		private ModData modData;
		private PrtFile prtFile;
		private List<uint[]> framePalettes;

		public bool ValidateArguments(IReadOnlyCollection<string> args)
		{
			return args.Count >= 1;
		}

		private void Run(Utility utility, string[] args)
		{
			const string prtFilename = "op2_art.prt";

			// HACK: The engine code assumes that Game.modData is set.
			Game.ModData = modData = utility.ModData;

			using (var stream = Game.ModData.DefaultFileSystem.Open(prtFilename))
			{
				framePalettes = LoadPalettes(stream);
				prtFile = LoadGroups(stream, out var palettes);
			}

			WriteSequences();
			Console.WriteLine($"Wrote sequences file: {OutputFilename}");

			WriteActors();
			Console.WriteLine($"Wrote rules file: {RulesOutputFilename}");
			Console.WriteLine($"Wrote rules example file: {RulesExampleOutputFilename}");
		}

		private void WriteActors()
		{
			var sb = new StringBuilder();
			sb.AppendLine("## This file was generated by CreateSequencesCommand.");
			sb.AppendLine("## Don't modify it yourself unless you know what you're doing.");
			sb.AppendLine(string.Empty);

			foreach (var actorRule in actorRules)
			{
				sb.AppendLine($"^{actorRule.Name}-generated:");
				sb.AppendLine($"\tRenderSprites:");
				sb.AppendLine($"\t\tImage: {actorRule.Name}");
				if (actorRule.Palette is "1" or "2")
				{
					// Building
					sb.AppendLine($"\t\tPalette: {actorRule.Palette}");
				}

				var overlayIndex = 0;
				foreach (var overlay in actorRule.Overlays)
				{
					sb.AppendLine($"\tWithIdleOverlay@{overlayIndex}:");
					sb.AppendLine($"\t\tSequence: {overlay.SequenceName}");
					if (!string.IsNullOrWhiteSpace(overlay.Palette))
					{
						sb.AppendLine($"\t\tPalette: {overlay.Palette}");
					}

					overlayIndex++;
				}

				sb.AppendLine(string.Empty);
			}

			using var sw = new StreamWriter(RulesOutputFilename);
			sw.Write(sb.ToString());

			const string placeholderHeader = @"## This file was generated by CreateSequencesCommand.
## If you want to modify one of these actors, take it out of this file and put it into the appropriate
## vehicles.yaml or structures.yaml file. Then make it inherit from your appropriate class like ^Op2Vehicle or ^Op2Building.
## instead of ^StubVehicle and ^StubBuilding, below.

^StubVehicle:
	Inherits: ^Vehicle
	Tooltip:
		Name: Example Vehicle
	Selectable:
		Class: E1
	Voiced:
		VoiceSet: GenericVoice
	Valued:
		Cost: 150
	Health:
		HP: 100
	RevealsShroud:
		Range: 8c0
	Mobile:
		Speed: 78

^StubBuilding:
	Inherits: ^Building
	MustBeDestroyed:
	Tooltip:
		Name: Example Building
	Selectable:
		Class: B1
	Valued:
		Cost: 150
	Health:
		HP: 100
	RevealsShroud:
		Range: 8c0

## Generated OP2 actors

";

			// Now write placeholder actors file
			sb = new StringBuilder();
			sb.Append(placeholderHeader);

			foreach (var actorRule in actorRules)
			{
				if (!actorRule.CreateExampleActor)
					continue;

				if (actorRule.ActorType is ActorType.Effect or ActorType.Decoration)
					continue;

				var inheritor = "^StubVehicle";
				if (actorRule.ActorType == ActorType.Building)
				{
					inheritor = "^StubBuilding";
				}

				sb.AppendLine($"{actorRule.Name}:");
				sb.AppendLine($"\tInherits@generated: ^{actorRule.Name}-generated");
				sb.AppendLine($"\tInherits: {inheritor}");
				sb.AppendLine(string.Empty);
			}

			using var sw2 = new StreamWriter(RulesExampleOutputFilename);
			sw2.Write(sb.ToString());
		}

		class SequenceSet
		{
			public int FrameType;
			public int Palette;
			public int PicOrder;
			public AnimationFacing[] AnimationFacings;

			public AnimationFrame[] GetFacingArray(int facing)
			{
				var frames = AnimationFacings[facing].Frames;
				var isEvenNumberOfFrames = frames.Length % 2 == 0;
				if (isEvenNumberOfFrames)
				{
					var halfFrames = frames.Length / 2;
					var isFirstHalfPopulated = frames.Take(halfFrames).All(x => x != null);
					var isSecondHalfUnpopulated = frames.Skip(halfFrames).Take(halfFrames).All(x => x == null);
					if (isFirstHalfPopulated && isSecondHalfUnpopulated)
					{
						frames = frames.Take(halfFrames).Concat(frames.Take(halfFrames)).ToArray();
					}
				}

				return AnimationFacings[facing].Frames.ToArray();
			}
		}

		class ActorOverlay
		{
			public string SequenceName;
			public string Palette;
		}

		class ActorRule
		{
			public string Name;
			public string Palette;
			public bool CreateExampleActor = true;
			public ActorType ActorType;
			public List<ActorOverlay> Overlays = new List<ActorOverlay>();
		}

		private ActorRule[] actorRules;

		private void WriteSequences()
		{
			var sb = new StringBuilder();
			sb.AppendLine("## This file was generated by CreateSequencesCommand.");
			sb.AppendLine("## Don't modify it yourself unless you know what you're doing.");
			sb.AppendLine(string.Empty);

			var newActorRules = new Dictionary<string, ActorRule>();

			foreach (var groupSequence in SequencesList.GroupSequenceSets)
			{
				sb.AppendLine($"{groupSequence.Name}:");
				foreach (var groupSequenceSet in groupSequence.Sets)
				{
					List<ImageGroup> groups;
					if (groupSequenceSet.LoopOffset > 0)
					{
						groups = prtFile.Groups
							.Skip(groupSequenceSet.Offset + groupSequenceSet.LoopOffset)
							.Take(groupSequenceSet.Length - groupSequenceSet.LoopOffset)
							.ToList();

						groups.AddRange(prtFile.Groups
							.Skip(groupSequenceSet.Offset)
							.Take(groupSequenceSet.LoopOffset));
					}
					else
					{
						groups = prtFile.Groups
							.Skip(groupSequenceSet.Offset)
							.Take(groupSequenceSet.Length)
							.ToList();
					}

					var typeGroupedFrames = new List<SequenceSet>();
					var frameCount = groups.Max(x => x.FrameCount);

					for (var frameIndex = 0; frameIndex < frameCount; frameIndex++)
					{
						var groupIndex = 0;
						foreach (var group in groups)
						{
							Op2Frame frame;
							if (frameIndex >= group.Frames.Length)
							{
								// Hack it - just repeat the first one
								frame = group.Frames[0];
							}
							else
							{
								frame = group.Frames[frameIndex];
							}

							var pics = frame.Pictures.OrderBy(x => x.PicOrder);
							foreach (var pic in pics)
							{
								var rawFrame = prtFile.ImageHeader[pic.ImgNumber];
								var halfWidth = (int)Math.Ceiling(rawFrame.PaddedWidth / 2.0);
								var halfHeight = (int)Math.Ceiling(rawFrame.Height / 2.0);
								var relX = (halfWidth - group.CenterX) + pic.PosX;
								var relY = (halfHeight - group.CenterY) + pic.PosY;

								var matchingSequenceFrames = typeGroupedFrames.Where(x => x.FrameType == rawFrame.ImageType)
									.ToList();

								var setFrame = false;
								foreach (var seqFrame in matchingSequenceFrames)
								{
									if (seqFrame.AnimationFacings[groupIndex].Frames[frameIndex] == null)
									{
										var animation = new AnimationFrame()
										{
											Frame = pic.ImgNumber,
											OffsetX = relX,
											OffsetY = relY
										};

										var ourGroup = seqFrame.AnimationFacings[groupIndex];
										ourGroup.Frames[frameIndex] = animation;
										setFrame = true;
										break;
									}
								}

								if (!setFrame)
								{
									// Need a new frameset for this image type
									var seqFrame = new SequenceSet
									{
										AnimationFacings = new AnimationFacing[groupSequenceSet.Length],
										FrameType = rawFrame.ImageType,
										Palette = rawFrame.Palette,
										PicOrder = pic.PicOrder
									};

									for (var i = 0; i < groupSequenceSet.Length; i++)
									{
										seqFrame.AnimationFacings[i] = new AnimationFacing
										{
											Frames = new AnimationFrame[frameCount]
										};
									}

									// Populate it too
									var animation = new AnimationFrame()
									{
										Frame = pic.ImgNumber,
										OffsetX = relX,
										OffsetY = relY
									};

									var ourGroup = seqFrame.AnimationFacings[groupIndex];
									ourGroup.Frames[frameIndex] = animation;

									typeGroupedFrames.Add(seqFrame);
								}
							}

							groupIndex++;
						}
					}

					string[] facings = { "e", "ne", "n", "nw", "w", "sw", "s", "se" };

					typeGroupedFrames = typeGroupedFrames.OrderBy(x => x.FrameType).ToList();

					Func<int, string> getTypeString = (inFrameType) =>
					{
						return inFrameType switch
						{
							1 => "sprite",
							4 or 5 => "shadow",
							_ => "unknown"
						};
					};

					Func<SequenceSet, int, string> getSequenceName = (inGroup, ind) =>
					{
						var seqName = $"{groupSequenceSet.Sequence}-{getTypeString(inGroup.FrameType)}" +
						       (ind == 0 ? "" : $"-id{ind}");
						if (inGroup.FrameType == 1 && groupSequenceSet.Sequence == "idle" && ind == 0)
						{
							seqName = "idle"; // Hack to have default idle sequence
						}

						return seqName;
					};

					var allSequenceNames = typeGroupedFrames.Select((x, index) => getSequenceName(x, index)).ToArray();

					sb.AppendLine($"\t# All sequences: {string.Join(", ", allSequenceNames)}");
					var zIndex = 0;
					var typeIndex = 0;
					foreach (var typeGroupedFrame in typeGroupedFrames)
					{
						var sequenceName = allSequenceNames[typeIndex];
						sb.AppendLine($"\t{sequenceName}:");
						sb.AppendLine($"\t\tLength: {frameCount}");
						sb.AppendLine($"\t\tFacings: {groupSequenceSet.Length}");
						sb.AppendLine($"\t\tZOffset: {zIndex}");
						sb.AppendLine($"\t\tCombine:");
						for (var facingIndex = 0; facingIndex < groupSequenceSet.Length; facingIndex++)
						{
							var framesArray = typeGroupedFrame.GetFacingArray(facingIndex);
							var animationGroup = typeGroupedFrame.AnimationFacings[facingIndex];
							for (var frameIndex = 0; frameIndex < animationGroup.Frames.Length; frameIndex++)
							{
								var frame = framesArray[frameIndex];
								var isBlank = frame == null;
								var innerSequenceName = $"{groupSequenceSet.Sequence}-facing{facingIndex}-{frameIndex}";
								if (isBlank)
								{
									sb.AppendLine($"\t\t\tblank.png: {innerSequenceName}");
									sb.AppendLine($"\t\t\t\tFrames: 0 # blank");
								}
								else
								{
									sb.AppendLine($"\t\t\top2_art.bmp: {innerSequenceName}");
									sb.AppendLine($"\t\t\t\tFrames: {frame.Frame}");
									sb.AppendLine($"\t\t\t\tOffset: {frame.OffsetX}, {frame.OffsetY}");
								}

								sb.AppendLine($"\t\t\t\tLength: 1");
								sb.AppendLine($"\t\t\t\tZOffset: {zIndex}");
							}
						}

						// Also assemble actor rules
						var overlayPalette = typeGroupedFrame.FrameType is 4 or 5 ? "shadow" : null;
						if (typeGroupedFrame.Palette == 1 && typeGroupedFrame.FrameType == 1)
						{
							// Eden building
							overlayPalette = "1";
						}

						if (typeGroupedFrame.Palette == 2 && typeGroupedFrame.FrameType == 1)
						{
							// Plymouth building
							overlayPalette = "2";
						}

						if (typeGroupedFrame.Palette == 8)
						{
							// UI item
							overlayPalette = "8";
						}

						ActorRule actorRule;
						if (newActorRules.ContainsKey(groupSequence.Name))
						{
							actorRule = newActorRules[groupSequence.Name];
						}
						else
						{
							actorRule = new ActorRule
							{
								Name = groupSequence.Name,
								Palette = overlayPalette,
								ActorType = groupSequence.ActorType,
								CreateExampleActor = groupSequence.CreateExampleActor,
							};

							newActorRules.Add(groupSequence.Name, actorRule);
						}

						if (sequenceName != "idle")
						{
							actorRule.Overlays.Add(new ActorOverlay
							{
								SequenceName = sequenceName,
								Palette = overlayPalette
							});
						}

						typeIndex++;
						zIndex -= 256;
					}

					break; // Only do idle set for now
				}

				sb.AppendLine(string.Empty);
			}

			actorRules = newActorRules.Values.ToArray();

			using var sw = new StreamWriter(OutputFilename);
			sw.Write(sb.ToString());
		}

		private List<uint[]> LoadPalettes(Stream s)
		{
			var cpal = s.ReadASCII(4);
			if (cpal != "CPAL")
				throw new InvalidDataException();

			var palettes = new List<uint[]>();
			var paletteCount = s.ReadUInt32();
			for (var p = 0; p < paletteCount; p++)
			{
				var ppal = s.ReadASCII(4);
				if (ppal != "PPAL")
					throw new InvalidDataException();

				var offset = s.ReadUInt32();

				var head = s.ReadASCII(4);
				if (head != "head")
					throw new InvalidDataException();

				var bytesPerEntry = s.ReadUInt32();
				var unknown = s.ReadUInt32();

				var data = s.ReadASCII(4);
				if (data != "data")
					throw new InvalidDataException();

				var paletteSize = s.ReadUInt32();
				var colors = paletteSize / bytesPerEntry;
				var paletteData = new Color[colors];
				for (var c = 0; c < colors; c++)
				{
					var blue = s.ReadByte();
					var green = s.ReadByte();
					var red = s.ReadByte();
					paletteData[c] = Color.FromArgb(red, green, blue);
					var reserved = s.ReadByte();
				}

				palettes.Add(paletteData.Select(d => (uint)d.ToArgb()).ToArray());
			}

			return palettes;
		}

		PrtFile LoadGroups(Stream s, out Dictionary<int, uint[]> palettes)
		{
			var spriteCount = s.ReadUInt32();
			var h = new PrtFile()
			{
				ImageCount = (int)spriteCount,
				ImageHeader = new Op2Image[spriteCount]
			};

			palettes = new Dictionary<int, uint[]>();
			var rawFrames = h.ImageHeader;
			for (var f = 0; f < rawFrames.Length; f++)
			{
				var paddedWidth = s.ReadUInt32();
				var dataOffset = s.ReadUInt32();
				var height = s.ReadUInt32();
				var width = s.ReadUInt32();
				var type = s.ReadUInt16();
				var palette = s.ReadUInt16();
				palettes.Add(f, framePalettes[palette]);

				var img = new Op2Image
				{
					PaddedWidth = paddedWidth,
					DataOffset = dataOffset,
					Height = height,
					Width = width,
					ImageType = type,
					Palette = palette,
				};

				h.ImageHeader[f] = img;
			}

			h.AllGroupCount = s.ReadInt32();
			h.AllFrameCount = s.ReadInt32();
			h.AllPicCount = s.ReadInt32();
			h.AllExtInfoCount = s.ReadInt32();
			h.Groups = new ImageGroup[h.AllGroupCount];

			for (var i = 0; i < h.AllGroupCount; i++)
			{
				var img = new ImageGroup
				{
					Unknown1 = s.ReadInt32(),
					SelLeft = s.ReadInt32(),
					SelTop = s.ReadInt32(),
					SelRight = s.ReadInt32(),
					SelBottom = s.ReadInt32(),
					CenterX = s.ReadInt32(),
					CenterY = s.ReadInt32(),
					Unknown8 = s.ReadInt32(),
					FrameCount = s.ReadInt32()
				};

				img.Frames = new Op2Frame[img.FrameCount];

				for (var j = 0; j < img.FrameCount; j++)
				{
					var frame = new Op2Frame
					{
						PicCount = s.ReadUInt8(),
						Unknown = s.ReadUInt8(),
					};

					frame.ExtUnknown1 = new BytePair[frame.PicCount >> 7];
					for (var k = 0; k < frame.PicCount >> 7; k++)
					{
						var bp = new BytePair
						{
							Byte1 = s.ReadUInt8(),
							Byte2 = s.ReadUInt8(),
						};

						frame.ExtUnknown1[k] = bp;
					}

					frame.ExtUnknown2 = new BytePair[frame.Unknown >> 7];
					for (var k = 0; k < frame.Unknown >> 7; k++)
					{
						var bp = new BytePair
						{
							Byte1 = s.ReadUInt8(),
							Byte2 = s.ReadUInt8(),
						};

						frame.ExtUnknown2[k] = bp;
					}

					frame.Pictures = new Op2Picture[frame.PicCount & 0x7F];
					for (var k = 0; k < frame.Pictures.Length; k++)
					{
						var pic = new Op2Picture
						{
							ImgNumber = s.ReadInt16(),
							Reserved = s.ReadUInt8(),
							PicOrder = s.ReadUInt8(),
							PosX = s.ReadInt16(),
							PosY = s.ReadInt16()
						};

						frame.Pictures[k] = pic;
					}

					img.Frames[j] = frame;
				}

				img.GroupExtCount = s.ReadInt32();
				img.Extended = new GroupExt[img.GroupExtCount];

				for (var j = 0; j < img.GroupExtCount; j++)
				{
					var ext = new GroupExt
					{
						Unknown1 = s.ReadInt32(),
						Unknown2 = s.ReadInt32(),
						Unknown3 = s.ReadInt32(),
						Unknown4 = s.ReadInt32(),
					};

					img.Extended[j] = ext;
				}

				h.Groups[i] = img;
			}

			return h;
		}
	}
}
